## The Field - Chapter 1 Coding the matrix ##

# Python uses 'j' for iorta i
3j

1 + 3j

# Airthmetic operation for complex numbers

(1+3j) + (4 + 5j) # addition is a element wise operation
(1+3j) - (4 + 5j) # subtraction is a element wise operation
(1+3j) * (4 + 5j) # Multiplication is not a element wise operation
(1+3j) / (4 + 5j) 
(1+3j) / 4 
(1+3j) ** 2

1+2j*3

# To obtain the real and imaginary part of the complex no.
x = 4+3j

x.real
x.imag

# type function can be used to obtain the class of the object
type(1+3j)

# plotting the complex no. on the complex plain
# Task 1.4.1
S = {2+2j, 3+2j, 1.75+1j, 2+1j, 2.25+1j, 2.5+1j, 2.75+1j, 3+1j, 3.25+1j}

# Download the module from the coding the matrix
from plotting import plot
plot(S,4)

# abs function can be used to calculate the absolute value of a complex number
abs(3+4j)
abs(1+1j)

# Conjugate of a complex number
(3+4j).conjugate()

# Adding the complex numbers
# Task 1.4.3
plot({1+2j+z for z in S},4)

# Quiz 1.4.4
plot({-2-2j+z for z in S},4)

## Scaling 
plot({z/2 for z in S},4)

# Rotation of a plot 
plot({z*1j/2 for z in S},4)

# Rotation of a plot
plot({z*1j/2 + 2 - 1j for z in S},4)

import image
image_data = image.file2image("img01.png")

#Task 1.4.10
image_data_lt_120 = [(y,188-x) for x in range(189) for y in range(166) if image_data[x][y][1] < 120]
plot(image_data_lt_120, scale = 200)

# Task 1.4.11
S_tuple = [(x.real,x.imag) for x in S]
S_tuple_X = [x[0] for x in S_tuple]
S_tuple_Y = [y[1] for y in S_tuple]
mean_S_X = sum(set(S_tuple_X))/len(set(S_tuple_X))
mean_S_Y = sum(set(S_tuple_Y))/len(set(S_tuple_Y))

def sub_centroid(z,mean_x, mean_y): return (z[0]-mean_x,z[1] - mean_y)

plot([sub_centroid(x,mean_S_X, mean_S_Y) for x in S_tuple],4)

# Task 1.4.12
pts_X = [x[0] for x in image_data_lt_120]
pts_Y = [y[1] for y in image_data_lt_120]
mean_pts_X = sum(set(pts_X))/len(set(pts_X))
mean_pts_Y = sum(set(pts_Y))/len(set(pts_Y))
plot([sub_centroid(x,mean_pts_X, mean_pts_Y) for x in image_data_lt_120],scale = 200)

from math import e
from math import pi

n = 20
w = e**((2*pi*1j)/n)

plot([w**x for x in range(n)],4)

# task 1.4.18
S = {2+2j, 3+2j, 1.75+1j, 2+1j, 2.25+1j, 2.5+1j, 2.75+1j, 3+1j, 3.25+1j}
plot({x * e**(pi/4 *1j) for x in S},4)

# Task 1.4.19
pts = [x+y*1j for (x,y) in image_data_lt_120]
plot(pts,200)
plot({x * e**(pi/4 *1j) for x in pts},200)

# Task 1.4.20
pts_centered = [sub_centroid(x,mean_pts_X, mean_pts_Y) for x in image_data_lt_120]
pts_centered_2 = [x+y*1j for (x,y) in pts_centered]

plot({(x * e**(pi/4 *1j))/2 for x in pts_centered_2},200)


# Problems
#Problem 1.7.1
def my_filter(L,num) : [x for x in L if x%num != 0]
mylist([1,2,4,5,7],2)

# Problem 1.7.2
def mylists(L) : return [list(range(1,x+1)) for x in L]
mylists([1,2,4])

# Problem 1.7.3
def my_function_composition(f,g): return {x:g[f[x]] for x in f}
my_function_composition({0:'a',1:'b'},{'a':'apple','b':'banana'})

# Problem 1.7.4
def mysum(L):
    current = 0
    for x in L:
        current = current + x
    return current

# Problem 1.7.5
def myProduct(L):
    current = 1
    for x in L:
        current = current*x
    return current

#Problem 1.7.6
def myMin(L):
    current = L[1]
    for x in L:
        if x < current:
            current = x
    return current

# Problem 1.7.7
def myConcat(L):
    current = ""
    for x in L:
        current = current + x
    return current

#Problem 1.7.8
def myUnion(L):
    current = set()
    for x in L:
        current = current | x
    return current

 